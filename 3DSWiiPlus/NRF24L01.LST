C51 COMPILER V9.52.0.0   NRF24L01                                                          08/08/2017 16:17:41 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE NRF24L01
OBJECT MODULE PLACED IN NRF24L01.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE NRF24L01.c OPTIMIZE(9,SPEED) REGFILE(.\3DSWiiPlus.ORC) BROWSE DEFINE(LCM_DR
                    -IVER_IST3932) DEBUG OBJECTEXTEND

line level    source

   1          #include <STRING.H>
   2          #include "NRF24L01.h"
   3          #include "SPI.h"
   4          #include "Uart.h"
   5          
   6          
   7          //#define DEBUG
   8          
   9          
  10          // 
  11          sbit NRF24L01_CS        = P3^4; // ƬѡƬ->nRF24L01
  12          sbit NRF24L01_CE        = P3^5; // ʹܣƬ->nRF24L01
  13          sbit NRF24L01_IRQ       = P3^6; // жϣnRF24L01->Ƭ
  14          
  15          // ָ
  16          #define READ_REG        0x00    // üĴ5λΪĴַ
  17          #define WRITE_REG       0x20    // дüĴ5λΪĴַֻеʹģʽɲ
  18          #define RD_RX_PLOAD     0x61    // RXЧݣ1~32ֽڡ֮FIFOĴеݱڽģʽ
  19          #define WR_TX_PLOAD     0xA0    // дTXЧݣ1~32ֽڡڷģʽ
  20          #define FLUSH_TX        0xE1    // TX FIFOĴģʽ
  21          #define FLUSH_RX        0xE2    // RX FIFOĴģʽáӦźŵʱҪΪʹӦźŲ
             -
  22          #define REUSE_TX_PL     0xE3    // ʹһݣCEΪߵĹУݰϵ·䡣ڷ͹б
             -ֹʹ
  23          #define NOP                     0xFF    // ղ״̬Ĵ
  24          
  25          // Ĵַ
  26          #define CONFIG          0x00    // üĴ
  27          #define EN_AA           0x01    // ʹԶӦ
  28          #define EN_RXADDR       0x02    // յַ
  29          #define SETUP_AW        0x03    // õַȣͨ
  30          #define SETUP_RETR      0x04    // Զط
  31          #define RF_CH           0x05    // Ƶͨ
  32          #define RF_SETUP        0x06    // ƵĴ
  33          #define STATUS          0x07    // ״̬Ĵ
  34          #define OBSERVE_TX      0x08    // ͼĴ
  35          #define CD                      0x09    // ز
  36          #define RX_ADDR_P0      0x0A    // ͨ0յַ󳤶:5ֽڣдֽڣдֽSETUP_AW趨
  37          #define RX_ADDR_P1      0x0B    // ͨ1յַ󳤶:5ֽڣдֽڣдֽSETUP_AW趨
  38          #define RX_ADDR_P2      0x0C    // ͨ2յַֽڿáֽڲֱRX_ADDR_P1[39:8]
  39          #define RX_ADDR_P3      0x0D    // ͨ3յַֽڿáֽڲֱRX_ADDR_P1[39:8]
  40          #define RX_ADDR_P4      0x0E    // ͨ4յַֽڿáֽڲֱRX_ADDR_P1[39:8]
  41          #define RX_ADDR_P5      0x0F    // ͨ5յַֽڿáֽڲֱRX_ADDR_P1[39:8]
  42          #define TX_ADDR         0x10    // ͵ַдֽڣǿShockBurst TMģʽRX_ADDR_P0˵ַ
  43          #define RX_PW_P0        0x11    // ͨ0Чݿȣ132ֽڣ
  44          #define RX_PW_P1        0x12    // ͨ1Чݿȣ132ֽڣ
  45          #define RX_PW_P2        0x13    // ͨ2Чݿȣ132ֽڣ
  46          #define RX_PW_P3        0x14    // ͨ3Чݿȣ132ֽڣ
  47          #define RX_PW_P4        0x15    // ͨ4Чݿȣ132ֽڣ
  48          #define RX_PW_P5        0x16    // ͨ5Чݿȣ132ֽڣ
  49          #define FIFO_STATUS     0x17    // FIFO״̬Ĵ
  50          
  51          
  52          // ͽݿȶ
C51 COMPILER V9.52.0.0   NRF24L01                                                          08/08/2017 16:17:41 PAGE 2   

  53          #define TX_ADDR_WIDTH   5       // 5ֽڵĵַ
  54          #define RX_ADDR_WIDTH   5       // 5ֽڵĵַ
  55          #define TX_PLOAD_WIDTH  8       // 8ֽڵûݿ
  56          #define RX_PLOAD_WIDTH  8       // 8ֽڵûݿ
  57          
  58          
  59          static u8 code TX_ADDRESS[TX_ADDR_WIDTH] = {0x10, 0x10, 0x10, 0x10, 0x10};  // һ̬͵ַ
  60          static u8 sta;
  61          
  62          
  63          /*
  64          ʼnRF24L01
  65          */
  66          void nRF24L01_Init(){
  67   1              P3M0 &= 0x8F;
  68   1              P3M1 &= 0x8F;           // /CSCEIRQΪ׼˫
  69   1              
  70   1              NRF24L01_CE = 0;        // RF24L01ģʽ
  71   1              NRF24L01_CS = 1;        // ֹSPI
  72   1              NRF24L01_IRQ = 1;       // жϸλ
  73   1      }
  74          
  75          /*
  76          regĴ1ֽ
  77          */
  78          u8 nRF24L01_SPI_Read(u8 reg){
  79   1              u8 reg_val;
  80   1              NRF24L01_CS = 0;                                        // CSͣSPIʼ
  81   1              SPI_SendAndReceive(reg);                        // ѡĴ
  82   1              reg_val = SPI_SendAndReceive(0);        // üĴֵ
  83   1              NRF24L01_CS = 1;                                        // CSߣSPIݴ
  84   1              return reg_val;                                         // 
  85   1      }
  86          
  87          /*
  88          regĴд1ֽ
  89          */
  90          u8 nRF24L01_SPI_Write(u8 reg, u8 value){
  91   1              u8 status;
  92   1              NRF24L01_CS = 0;                                        // CSͣSPIʼ
  93   1              status = SPI_SendAndReceive(reg);       // ѡĴ
  94   1              SPI_SendAndReceive(value);                      // ֵдüĴ
  95   1              NRF24L01_CS = 1;                                        // CSߣSPIݴ
  96   1              return status;                                          // nRF24L01״̬
  97   1      }
  98          
  99          
 100          /*
 101          regĴsizeֽڡͨڶȡͨݻ/͵ַ
 102          */
 103          u8 nRF24L01_SPI_Read_Buf(u8 reg, u8* pBuf, u8 size){
 104   1              u8 status, i;
 105   1              NRF24L01_CS = 0;                                                // CSͣSPIʼ
 106   1              status = SPI_SendAndReceive(reg);               // ѡĴ
 107   1              for(i=0;i<size;++i)
 108   1                      pBuf[i] = SPI_SendAndReceive(0);        // üĴֵ
 109   1              NRF24L01_CS = 1;                                                // CSߣSPIݴ
 110   1              return status;                                                  // nRF24L01״̬
 111   1      }
 112          
 113          /*
 114          pBufед뵽nRF24L01ͨд뷢ͨݻ/͵ַ
C51 COMPILER V9.52.0.0   NRF24L01                                                          08/08/2017 16:17:41 PAGE 3   

 115          */
 116          u8 nRF24L01_SPI_Write_Buf(u8 reg, u8* pBuf, u8 size){
 117   1              u8 status, i;
 118   1              NRF24L01_CS = 0;                                                // CSõͣʼ
 119   1              status = SPI_SendAndReceive(reg);               // ѡĴͬʱ״̬
 120   1              for(i=0;i<size;++i)
 121   1                      SPI_SendAndReceive(pBuf[i]);            // ֽдnRF24L01
 122   1              NRF24L01_CS = 1;                                                // CSߣݴ
 123   1              return status;                                                  // ״̬Ĵ
 124   1      }
 125          
 126          /*
 127          ǷnRF24L01豸
 128          */
 129          bit nRF24L01_Check(){
 130   1              u8 buf[TX_ADDR_WIDTH];
 131   1              u8 i = 0;
 132   1              nRF24L01_SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADDR_WIDTH); // д5ֽڵĵַ.
 133   1              nRF24L01_SPI_Read_Buf(TX_ADDR, buf, TX_ADDR_WIDTH);                                             // дĵַ
 134   1              for(i=0;i<TX_ADDR_WIDTH;++i)
 135   1                      Uart_Hex(buf[i]);
 136   1              Uart_String("\r\n");
 137   1              return memcmp(TX_ADDRESS, buf, TX_ADDR_WIDTH) == 0 ? 1 : 0;
 138   1      }
 139          
 140          /*
 141          nRF24L01Ϊģʽ
 142          */
 143          void nRF24L01_TX_Mode(){
 144   1              NRF24L01_CE = 0;                                                                                                                        // ģʽ
 145   1              nRF24L01_SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADDR_WIDTH);         // д뷢͵ַ
 146   1              nRF24L01_SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADDR_WIDTH);      // ΪӦ豸ͨ
             -0ַͷ͵ַͬ
 147   1              nRF24L01_SPI_Write(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);                                       // ͨ0ѡͷͨͬЧݿ
 148   1      #ifdef DEBUG
                      nRF24L01_SPI_Write(WRITE_REG + EN_AA, 0x00);                                                            // ֹͨ0ԶӦ
                      nRF24L01_SPI_Write(WRITE_REG + EN_RXADDR, 0x01);                                                        // ʹܽͨ0
                      nRF24L01_SPI_Write(WRITE_REG + SETUP_RETR, 0x00);                                                       // ֹԶط
              #else
 153   1              nRF24L01_SPI_Write(WRITE_REG + EN_AA, 0x01);                                                            // ʹܽͨ0ԶӦ
 154   1              nRF24L01_SPI_Write(WRITE_REG + EN_RXADDR, 0x01);                                                        // ʹܽͨ0
 155   1              nRF24L01_SPI_Write(WRITE_REG + SETUP_RETR, 0x0A);                                                       // Զطʱȴ250us+86usԶط10
 156   1      #endif
 157   1              nRF24L01_SPI_Write(WRITE_REG + RF_CH, 0x00);                                                            // ѡƵͨΪ2.4GHz
 158   1              nRF24L01_SPI_Write(WRITE_REG + RF_SETUP, 0x0F);                                                         // ݴ2Mbps书0dBmŴ
             -
 159   1              NRF24L01_CE = 1;                                                                                                                        // CEģʽ
 160   1              Delay10us(1);                                                                                                                           // ȴ10usתΪģʽ
 161   1      }
 162          
 163          /*
 164          nRF24L01Ϊģʽ
 165          */
 166          void nRF24L01_RX_Mode(){
 167   1              NRF24L01_CE = 0;                                                                                                                        // ģʽ
 168   1              nRF24L01_SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADDR_WIDTH);      // 豸ͨ0ʹúͷ
             -豸ͬķ͵ַ
 169   1              nRF24L01_SPI_Write(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);                                       // ͨ0ѡͷͨͬЧݿ
 170   1      #ifdef DEBUG
                      nRF24L01_SPI_Write(WRITE_REG + EN_AA, 0x00);                                                            // ýͨ0ԶӦ
                      nRF24L01_SPI_Write(WRITE_REG + EN_RXADDR, 0x01);                                                        // ʹܽͨ0
              #else
C51 COMPILER V9.52.0.0   NRF24L01                                                          08/08/2017 16:17:41 PAGE 4   

 174   1              nRF24L01_SPI_Write(WRITE_REG + EN_AA, 0x01);                                                            // ʹܽͨ0ԶӦ
 175   1              nRF24L01_SPI_Write(WRITE_REG + EN_RXADDR, 0x01);                                                        // ʹܽͨ0
 176   1      #endif
 177   1              nRF24L01_SPI_Write(WRITE_REG + RF_CH, 0x00);                                                            // ѡƵͨΪ2.4GHz
 178   1              nRF24L01_SPI_Write(WRITE_REG + RF_SETUP, 0x0F);                                                         // ݴ2Mbps书0dBmŴ
 179   1              nRF24L01_SPI_Write(WRITE_REG + CONFIG, 0x0F);                                                           // жϣCRCʹܣ16λCRCУ飬ϵ磬ģʽ
 180   1              NRF24L01_CE = 1;                                                                                                                        // CEģʽ
 181   1      }
 182          
 183          /*
 184          ݰCE=110us130us䣬ֵ0ɹ0Ϊʧܡ1ﵽط
             -ֵҪֲ
 185          */
 186          u8 nRF24L01_Send(u8* pBuf){
 187   1              u8 ret;
 188   1              NRF24L01_CE = 0;                                                                                                                        // ģʽ
 189   1              nRF24L01_SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADDR_WIDTH);         // д뷢͵ַ
 190   1              nRF24L01_SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADDR_WIDTH);      // ΪӦ豸ͨ0
             -ַͷ͵ַͬ
 191   1              nRF24L01_SPI_Write_Buf(WR_TX_PLOAD, pBuf, TX_PLOAD_WIDTH);                                      // дݰTX FIFO
 192   1              nRF24L01_SPI_Write(WRITE_REG + CONFIG, 0x0E);                                                           // жϣCRCʹܣ16λCRCУ飬ϵ磬ģʽ
 193   1              NRF24L01_CE = 1;                                                                                                                        // CE豸
 194   1              while(NRF24L01_IRQ);                                                                                                            // ȴж
 195   1              sta = nRF24L01_SPI_Read(STATUS);                                                                                        // ״̬Ĵ
 196   1              if(sta & (1 << 4)){                                                                                                                     // ﵽط
 197   2                      nRF24L01_SPI_Write(FLUSH_TX, 0);                                                                                // TX
 198   2                      ret = 1;
 199   2              }
 200   1              if(sta & (1 << 5)){                                                                                                                             // ݳɹ
 201   2                      ret = 0;
 202   2              }
 203   1              nRF24L01_SPI_Write(WRITE_REG + STATUS, sta);                                                            // ״̬Ĵ
 204   1              return ret;
 205   1      }
 206          
 207          /*
 208          ݰֵ0ɹ0Ϊʧ
 209          */
 210          u8 nRF24L01_Recv(u8* pBuf){
 211   1              u8 ret = 1;
 212   1              sta = nRF24L01_SPI_Read(STATUS);                                                                // ״̬Ĵ
 213   1              if(sta & (1 << 6)){
 214   2                      //NRF24L01_CE = 0;
 215   2                      nRF24L01_SPI_Read_Buf(RD_RX_PLOAD, pBuf, TX_PLOAD_WIDTH);       // RX FIFO
 216   2                      ret = 0;
 217   2              }
 218   1              nRF24L01_SPI_Write(FLUSH_RX, 0);
 219   1              nRF24L01_SPI_Write(WRITE_REG + STATUS, sta);                                    // RX_DSжϱ־
 220   1              return ret;
 221   1      }
 222          
 223          /*
 224          ȡĴֵר
 225          */
 226          u8 nRF24L01_TestReg(u8 reg){
 227   1              return nRF24L01_SPI_Read(reg);
 228   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    476    ----
   CONSTANT SIZE    =      8    ----
C51 COMPILER V9.52.0.0   NRF24L01                                                          08/08/2017 16:17:41 PAGE 5   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
