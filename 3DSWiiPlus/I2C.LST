C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN I2C.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE I2C.c OPTIMIZE(9,SPEED) REGFILE(.\3DSWiiPlus.ORC) BROWSE DEFINE(LCM_DRIVER_
                    -IST3932) DEBUG OBJECTEXTEND

line level    source

   1          #include <INTRINS.h>
   2          #include <STRING.H>
   3          #include "I2C.h"
   4          #include "Uart.h"
   5          
   6          
   7          /*
   8                  I2C.c
   9                  ׼80C51ƬģI2Cߵ
  10                  ѧϰοṩκοɿԷĵҵĿ
  11          ˵
  12                  һC51ģI2CЭľ汾
  13                  ֻһģʽǶģʽ
  14                  I2CЭеʱͬ
  15                  Ҫ˽ⱾϸڣοPhilips˾Э׼
  16          ÷
  17                  1. ļI2C.hI2C.cһƵĹļ
  18                  2. ʵʵƬͺţSFRͷļ<reg52.h>
  19                  3. ʵʵ·޸I2CźSCLSDAĶ
  20                  4. ͨ궨I2C_DELAY_VALUEI2CߵٶʹʵҪ
  21                  5. ļI2C.cӽУҪĵطͷļI2C.h
  22                  6. main()ĿʼҪһγʼI2C_Init()
  23                  7. I2C_Puts()I2C_Gets()I2Cۺ϶д뿴עͺʹ
  24                  8. ȫʵıʶI2C_ͷЧͻ
  25                  9. ע⣺ӻַ7λַʾдλλЧ˵ַȡֵΧΪ0~0x7F
  26          */
  27          
  28          // I2CʱӵʱֵҪʵ޸ģȡֵ1255
  29          // STC-Y5ָƬ@30MHzƵ£ֻҪֵ32ôʱʱͳ4.7uS
  30          // ǵ1TƬIOڿӦĸı䣬ԼݺͷֲɵĲαԵֵͣӦԴ
             -ڼֵ
  31          #define I2C_DELAY_VALUE         64
  32          
  33          // I2Cֹͣһοʼ֮ǰĵȴʱ䣬ȡֵ165535
  34          // ȴʱΪ((I2C_STOP_WAIT_VALUE*5)/Ƶ)uS
  35          // ڶȡֵΪ1ɣĳЩ˵ϳʱǱ
  36          #define I2C_STOP_WAIT_VALUE             1
  37          
  38          // I2CȴӻӦĳʱʱ䣬ȡֵ1~65535
  39          #define I2C_WAIT_ACK_TIMEOUT    255
  40          
  41          
  42          // ģI2CߵŶ
  43          sbit I2C_SDA = P3^2;
  44          sbit I2C_SCL = P3^3;
  45          
  46          
  47          // еַΧǷI2C豸
  48          static u8 xdata I2CDevices[16] = {0};
  49          
  50          
  51          /*
  52          I2C_Delay()
  53          ܣʱģI2Cר
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 2   

  54          ˵ʱʱΪ((4+2+I2C_DELAY_VALUE*4+4)/Ƶ)uS
  55          */
  56          static void I2C_Delay(){
  57   1              u8 I2C_Delay_t = (I2C_DELAY_VALUE);
  58   1              while(--I2C_Delay_t != 0);
  59   1      }
  60          
  61          /*
  62          I2C_Init()
  63          ܣI2C߳ʼʹߴڿ״̬
  64          ˵main()ĿʼͨӦҪִһα
  65          */
  66          void I2C_Init(){
  67   1              P3M0 |= 0x0C;
  68   1              P3M1 |= 0x0C;   // I2C_SCLI2C_SDAóɿ©
  69   1              
  70   1              memset(I2CDevices, 0, sizeof(I2CDevices));
  71   1              
  72   1              I2C_SCL = 1;
  73   1              I2C_Delay();
  74   1              I2C_SDA = 1;
  75   1              I2C_Delay();
  76   1      }
  77          
  78          /*
  79          I2C_Start()
  80          ܣI2Cߵʼ״̬
  81          ˵
  82                  SCLڸߵƽڼ䣬SDA½ʱI2C
  83                  SDASCLʲôƽ״̬ȷʼ״̬
  84                  Ҳظʼ״̬
  85                  ִкI2Cߴæ״̬
  86          */
  87          void I2C_Start(){
  88   1              I2C_SDA = 1;
  89   1              I2C_Delay();
  90   1              I2C_SCL = 1;
  91   1              I2C_Delay();
  92   1              I2C_SDA = 0;
  93   1              I2C_Delay();
  94   1              I2C_SCL = 0;
  95   1              I2C_Delay();
  96   1      }
  97          
  98          /*
  99          I2C_Write()
 100          ܣI2Cд1ֽڵ
 101          
 102                  datҪдϵ
 103          */ 
 104          void I2C_Write(u8 dat){
 105   1              u8 t = 8;
 106   1              do{
 107   2                      I2C_SDA = (bit)(dat & 0x80);
 108   2                      I2C_Delay();
 109   2                      I2C_SCL = 1;
 110   2                      I2C_Delay();
 111   2                      I2C_SCL = 0;
 112   2                      I2C_Delay();
 113   2                      dat <<= 1;
 114   2              }while(--t != 0);
 115   1      }
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 3   

 116          
 117          /*
 118          I2C_Read()
 119          ܣӴӻȡ1ֽڵ
 120          أȡһֽ
 121          */
 122          u8 I2C_Read(){
 123   1              u8 dat;
 124   1              u8 t = 8;
 125   1              I2C_SDA = 1;    // ڶȡ֮ǰҪSDA
 126   1              I2C_Delay();
 127   1              do{
 128   2                      I2C_SCL = 1;            // ͷSCLߣȴӻ
 129   2                      I2C_Delay();
 130   2                      while(!I2C_SCL);        // ȴӻͷSCLӻͷSCLӻѾSDA׼ã̶ȡ
 131   2                      dat <<= 1;
 132   2                      dat |= I2C_SDA;
 133   2                      I2C_SCL = 0;
 134   2                      I2C_Delay();
 135   2              }while(--t != 0);
 136   1              return dat;
 137   1      }
 138          
 139          /*
 140          I2C_GetAck()
 141          ܣȡӻӦλ
 142          أ
 143                  0ӻӦ
 144                  1ӻӦ
 145          ˵
 146                  ӻյϵĵַԼĵַͬӦλ
 147                  ӻյÿֽڵݺҪӦλ
 148                  ӻյ1ֽڵݺһҪӦλ
 149          */
 150          bit I2C_GetAck(){
 151   1              u16 timeout = I2C_WAIT_ACK_TIMEOUT;
 152   1              I2C_SDA = 1;
 153   1              I2C_Delay();
 154   1              I2C_SCL = 1;
 155   1              I2C_Delay();
 156   1              while(I2C_SDA){
 157   2                      timeout--;
 158   2                      if(timeout==0){
 159   3                              return 1;
 160   3                      }
 161   2              }
 162   1              I2C_SCL = 0;
 163   1              I2C_Delay();
 164   1              return 0;
 165   1      }
 166          
 167          /*
 168          I2C_PutAck()
 169          ܣӦλӦλ
 170          
 171                  ack=0Ӧλ
 172                  ack=1Ӧλ
 173          ˵
 174                  ڽÿһֽڵݺ󣬶ӦӦλ
 175                  ڽһֽڵݺӦӦλ
 176          */
 177          void I2C_PutAck(bit ack){
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 4   

 178   1              I2C_SDA = ack;
 179   1              I2C_Delay();
 180   1              I2C_SCL = 1;
 181   1              I2C_Delay();
 182   1              I2C_SCL = 0;
 183   1              I2C_Delay();
 184   1      }
 185          
 186          /*
 187          I2C_Stop()
 188          ܣI2Cߵֹͣ״̬
 189          ˵
 190                  SCLڸߵƽڼ䣬SDAʱֹͣI2C
 191                  SDASCLʲôƽ״̬ȷֹͣ״̬
 192                  ִкI2Cߴڿ״̬
 193          */
 194          void I2C_Stop(){
 195   1              u16 t = I2C_STOP_WAIT_VALUE;
 196   1              I2C_SDA = 0;
 197   1              I2C_Delay();
 198   1              I2C_SCL = 1;
 199   1              I2C_Delay();
 200   1              I2C_SDA = 1;
 201   1              I2C_Delay();
 202   1              while(--t != 0);        // һβStart֮ǰҪһʱ
 203   1      }
 204          
 205          /*
 206          I2C_EnumerateAllDevices()
 207          ܣַָΧеI2Cöٴڵַ
 208          
 209                  startʼַ7λַдλ
 210                  endַ7λַдλ
 211          ˵
 212                  ͼдַӦ˵Ϸ
 213          */
 214          void I2C_EnumerateAllDevices(u8 start, u8 end){
 215   1              u8 i = start;
 216   1              I2C_Init();
 217   1              for(;i<=end;++i){
 218   2                      bit result;
 219   2                      I2C_Start();
 220   2                      I2C_Write(i << 1);      // дӻַ
 221   2                      result = I2C_GetAck();
 222   2                      I2C_Stop();
 223   2                      if(result == 0){
 224   3                              I2CDevices[i >> 3] |= (1 << (i & 7));
 225   3                      }else{
 226   3                              I2CDevices[i >> 3] &= ~(1 << (i & 7));
 227   3                      }
 228   2              }
 229   1      }
 230          
 231          /*
 232          I2C_CheckSlaveValidity()
 233          ܣַָǷ豸
 234          
 235                  addrӻַ7λַдλ
 236          أ
 237                  0豸
 238                  1豸
 239          ˵
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 5   

 240                  ʹ֮ǰѾùI2C_EnumerateAllDevices()豸ö
 241          */
 242          bit I2C_CheckSlaveValidity(u8 addr){
 243   1              u8 i;
 244   1              for(i=0;i<16;++i){
 245   2                      Uart_Hex(I2CDevices[i]);
 246   2                      Uart_String(",");
 247   2              }
 248   1              Uart_String("\r\n");
 249   1              if((I2CDevices[addr >> 3] & (1 << (addr & 7))) != 0){
 250   2                      Uart_String("Found.\r\n");
 251   2                      return 1;
 252   2              }else{
 253   2                      Uart_String("Not Found.\r\n");
 254   2                      return 0;
 255   2              }
 256   1      }
 257          
 258          /*
 259          I2C_Puts()
 260          ܣI2CۺϷͺӻͶֽڵ
 261          
 262                  SlaveAddrӻַ7λַдλ
 263                  SubAddrӻӵַ
 264                  SubModӵַģʽ0ӵַ1ֽӵַ2˫ֽӵַ
 265                  *datҪ͵
 266                  Sizeݵֽ
 267          أ
 268                  0ͳɹ
 269                  1ڷ͵ַг쳣
 270                  -1ڷݹг쳣
 271          ˵
 272                  ܹܺõӦгI2CǷӵַ
 273                  ӻûӵַʱSubAddr⣬SubModӦΪ0
 274          */
 275          s8 I2C_Puts(u8 SlaveAddr, u16 SubAddr, u8 SubMod, u8* dat, u16 Size){
 276   1              // ʱ
 277   1              u8 i;
 278   1              u8 a[3];
 279   1              // 鳤
 280   1              if(Size == 0)return 0;
 281   1              // ׼ӻַ
 282   1              a[0] = (SlaveAddr << 1);
 283   1              // ӵַģʽ
 284   1              if(SubMod > 2)SubMod = 2;
 285   1              // ȷӵַ
 286   1              switch(SubMod){
 287   2              case 0:
 288   2                      break;
 289   2              case 1:
 290   2                      a[1] = (u8)(SubAddr & 0xFF);
 291   2                      break;
 292   2              case 2:
 293   2                      a[1] = (u8)((SubAddr >> 8) & 0xFF);
 294   2                      a[2] = (u8)(SubAddr & 0xFF);
 295   2                      break;
 296   2              default:
 297   2                      break;
 298   2              }
 299   1              // ʹӻַŷӵַӵַĻ
 300   1              SubMod++;
 301   1              I2C_Start();
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 6   

 302   1              for(i=0;i<SubMod;++i){
 303   2                      I2C_Write(a[i]);
 304   2                      if(I2C_GetAck()){
 305   3                              I2C_Stop();
 306   3                              return 1;
 307   3                      }
 308   2              }
 309   1              // 
 310   1              do{
 311   2                      I2C_Write(*dat++);
 312   2                      if(I2C_GetAck())break;
 313   2              }while(--Size != 0);
 314   1              // ϣֹͣI2Cߣؽ
 315   1              I2C_Stop();
 316   1              if(Size == 0){ 
 317   2                      return 0;
 318   2              }else{
 319   2                      return -1;
 320   2              }
 321   1      }
 322          
 323          /*
 324          I2C_Gets()
 325          ܣI2CۺϽպӴӻնֽڵ
 326          
 327                  SlaveAddrӻַ7λַдλ
 328                  SubAddrӻӵַ
 329                  SubModӵַģʽ0ӵַ1ֽӵַ2˫ֽӵַ
 330                  *datյ
 331                  Sizeݵֽ
 332          أ
 333                  0ճɹ
 334                  1ڽչ̵ķ͵ַʱ쳣
 335          ˵
 336                  ܹܺõӦгI2CǷӵַ
 337                  ӻûӵַʱSubAddr⣬SubModӦΪ0
 338          */
 339          s8 I2C_Gets(u8 SlaveAddr, u16 SubAddr, u8 SubMod, u8* dat, u16 Size){
 340   1              // ʱ
 341   1              u8 i;
 342   1              u8 a[3];
 343   1              // 鳤
 344   1              if(Size == 0)return 0;
 345   1              // ׼ӻַ
 346   1              a[0] = (SlaveAddr << 1);
 347   1              // ӵַģʽ
 348   1              if(SubMod > 2)SubMod = 2;
 349   1              // ӵַĴӻҪȷʹӻַӵַ
 350   1              if(SubMod != 0){
 351   2                      //ȷӵַ
 352   2                      if(SubMod == 1){
 353   3                              a[1] = (u8)(SubAddr & 0xFF);
 354   3                      }else{
 355   3                              a[1] = (u8)((SubAddr >> 8) & 0xFF);
 356   3                              a[2] = (u8)(SubAddr & 0xFF);
 357   3                      }
 358   2                      // ʹӻַŷӵַ
 359   2                      SubMod++;
 360   2                      I2C_Start();
 361   2                      for(i=0;i<SubMod;++i){
 362   3                              I2C_Write(a[i]);
 363   3                              if(I2C_GetAck()){
C51 COMPILER V9.52.0.0   I2C                                                               08/10/2017 10:00:37 PAGE 7   

 364   4                                      I2C_Stop();
 365   4                                      return 1;
 366   4                              }
 367   3                      }
 368   2              }
 369   1              // I2C_Start()ӵַĴӻظʼ״̬
 370   1              // ӵַĴӻʼ״̬
 371   1              I2C_Start();
 372   1              // ʹӻַ
 373   1              I2C_Write(a[0] + 1);
 374   1              if(I2C_GetAck()){
 375   2                      I2C_Stop();
 376   2                      return 1;
 377   2              }
 378   1              // 
 379   1              for(;;){
 380   2                      *dat++ = I2C_Read();
 381   2                      if(--Size == 0){
 382   3                              I2C_PutAck(1);
 383   3                              break;
 384   3                      }
 385   2                      I2C_PutAck(0);
 386   2              }
 387   1              // ϣֹͣI2Cߣؽ
 388   1              I2C_Stop();
 389   1              return 0;
 390   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    632    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =     16    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
